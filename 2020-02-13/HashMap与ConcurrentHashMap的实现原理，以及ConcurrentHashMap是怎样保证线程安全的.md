## HashMap实现

在java中， HashMap是一个“链表散列“的数据结构，是由数组以及链表共同实现的。它的底层是一个数组，数组中的每一项都有一个链表。每当新建一个HashMap的时候，都会初始化一个数组。该数组的类型位键值对<key,value>。通过对key进行hash，我们可以得到元素在该数组中的索引位置，从而进行插入查找等操作。如果发生哈希碰撞，每一项的链表将会把碰撞后共享相同哈希值的元素连接起来形成一个链表。 



- 线程不安全。例：在并发环境下，扩容（transfer（））可能会形成环状链表，导致get操作时，cpu空转

- 可以存储null键与null值

- 在不要求thread synchronization（线程同步）为优选

- 每次扩容size*2， 并重新计算hash位置，然后重新插入（易产生无效扩容，比如扩容后没有后续插入）；扩容条件为当前en容量所占75%（“负载极限”为0.75）

- 降低负载极限，加大初始大小可以降低哈希冲突的概率（空间换时间）先试试







> HashTable是一种线程安全但效率底下的映射方式，因为整个table使用一把锁。

## ConcurrentHashMap实现

与HashMap相似，底层采用数组与链表构成。引入红黑树进一步提高性能

- 线程安全

- Key与value都不能为null





## ConcurrentHashMap如何保证线程安全？

- JDK 1.8之前： 将HashMap分为若干segments，每段加reentrantLock可重入锁，且每段segment例存储若干HashEntry数组，在操作时，只需锁住当前segment，降低了多线程竞争，可以使线程之间并发操作提高效率。

- JDK 1.8之后：引入红黑树，因为链表查询的时间复杂度为O(n)，红黑树查询的时间复杂度为O(log(n))，所以在结点比较多的情况下使用红黑树可以大大提升性能。并采用CAS无锁算法与synchronized保证并发安全，支持并发扩容，数据结构变更为数组+链表+红黑树，提高性能。
