## 解决了什么问题？

1. 使用volatile禁止编译器优化而重排序指令

- 单线程情况下，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。但是会影响线程并发执行的正确性，例子如图下。

![](https://secure-static.wolai.com/static/ah8mN4LbgTdQgJtPcm96Ad/Screenshot Capture - 2021-02-13 - 21-24-37.png)

  2. 关于volatile修饰的变量，保证每个线程读到的值是最新的，而不是缓存中的值。

- 对于volatile修饰的变量进行写入操作时，保证直接写入内存而不是线程缓存，从而确保内存可见性。(可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值)



## 实现原理是什么？

现在处理器的执行速度与读写速度的差异造成了潜在的效率问题，故需要处理器和内存之间增加多级缓存来提升效率，与此同时，多级缓存也导致了缓存数据不一致的问题。

对于被volatile变量，当它被进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，强制缓存中的该变量写回系统内存中。

但是其他处理器缓存的值仍然可能是旧值，所以需要缓存一致性协议。该协议允许每个处理器当发现自己缓存行相应的内存地址被修改的时候，将当前处理器的缓存航设置成无效状态，如果想要再次对该变量进行操作，就要被强制重新从主内存内读写。

总结：被volatile修饰的变量，每次值被修改后都被强制刷主内存。同时其他处理器遵守缓存一致性协议，也会停止当前操作，强制从主内存再次读取正确的值，保证了volatile修饰的变量在并发编程中的值是被正确读取的。

volatile保证了可见性，有序性，但不能保证原子性，故不能替代锁的作用



